# <p style="text-align: center;">**Помощь при работе с Git**</p>

## **Основные команды**

* **git help**

* **git help <название_команды>** по конкретной команде. Например, clone: git help clone

* **git config --global user.name "Name Lastname"** указание имени пользователя

* **git config --global user. email user@mail.ru** указание email пользователя

* **git --version** установленная версия Git

* **git config --list** проверка текущих настроек

* **git status** Показывает состояние файлов в рабочей директории и индексе: какие изменены, но не добавлены в индекс; какие ожидают коммита в индексе. + подсказки, как изменить состояние файлов

* **git clean** Удаляет мусор из рабочей директории. Это могут быть результаты сборки проекта или файлы конфликтов слияний
**clear** очищает терминал

* **git init** Когда создан проект (папка) и написаны первые строки кода, нужно инициализировать проект. Превращает папку в репозиторий, где Git  начинает отслеживать файлы и их изменения. Делается единожды

* **git add название_файла** Перед сохранением созданные файлы и изменения нужно проиндексировать
* **git add .** Можно использовать эту команду, если создано много файлов или внесено много изменений к ним.

* **git commit** Сохраняет текущее состояние рабочего репозитория

* **git commit -m "название коммита"** после индексации файлы можно закоммитить (сохранить)

* **git commit -am "название коммита"** Позволяет одновременно проиндексировать файлы (за которыми уже ведется слежка) и закоммитить их

* **git log** покажет пару последних коммитов
* **git reflog** выведет список всех коммитов. Чтобы выйти из списка, нажать "Q"

* **git log -p** Позволяет подробно изучить изменения, внесенные в каждый файл

* **git diff**
Просмотр разницы между текущим состоянием и последним коммитом. Или для сравнения других коммитов (для этого через пробел нужно ввести две четверки первых букв имен необходимых коммитов). Перед переключением версии файла в Git использовать git log, чтобы увидеть количество сохранений

* **fast-forward**

## **Дерево коммитов**
HEAD - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данным момент работаем. HEAD всегда указывает на последний коммит из вашего локального дерева. Большинство команд Git, изменяющих рабочее дерево, начнут с изменения HEAD. Обычно HEAD указывает на имя ветки. Когда вы делаете коммит, статус ветки этого коммита меняется и это изменение видно через HEAD.

Отделение (detaching) HEAD означает лишь присвоение его не ветке, а конкретному коммиту. Для этого на последнем коммита набрать **git checkout идентификатор_коммита** (hush)

Относительные ссылки - мощный инструмент, но мы покажем два простых способа использования:
* Перемещение на один коммит назад ^ (оператор каретки). Когда мы добавляем его к имени ссылки, Git воспринимает это как указание найти родителя указанного коммита.

**git checkout main^** означает "первый родитель ветки main". 

**git checkout main^^** означает прародитель (родитель родителя) main

Можно также использовать HEAD как относительную ссылку - **git checkout HEAD^**
* Перемещение на несколько коммитов назад **git checkout HEAD~<число>** . Укажем после ~ число коммитов, через которые надо пройти. К тильде (опционально) можно добавить количество родительских коммитов, через которые нужно пройти.

# **Ветвления**

* Ветка - это набор commit, которые идут друг за другом. У ветки есть название, основную ветку чаще всего называют master/main

* Другие ветки - это отдельное место для реализации нового функционала или исправление багов (ошибок) нашего проекта. То есть, с отдельной веткой вы делаете что угодно, а затем сливаете эти изменения в основную ветку master

*! Не рекомендую создавать commit напрямую в master . Лучше для этого заводить новую ветку и все изменения писать там.*

**git branch** выводит список всех веток, * отмечена та, в которой находимся

Чтобы создать новую ветку вводим:
**git branch <название_ветки>**

**git checkout -b <название_ветки>** создание ветки и позволяет сразу переключиться в новую ветку. Вносить изменения в новую ветку можно сразу после ее создания.

! При создании новой ветки, старайтесь называть ее кратким и ёмким именем. Чтобы сразу было понятно, что именно изменялось по проекту. Если вы используете, какую-нибудь систему для ведения задач, то можете в начале названия ветки указывать ID задачи, чтобы можно было легко найти, на основе какой задачи была создана ветка. Например вот так: 3424_fix_catalog_ajax*

В каждом новом commit следует оставлять коммент и в нем описывать суть изменений.

**git checkout <название_ветки>** переключение между ветками.

После завершения работы над своей задачей ветку можно слить в master. Для этого нужно переключиться в ветку master **git checkout master** 

Делаем слияние вашей ветки в ветку, в которой вы находитесь **git merge <название_ветки>**. Команда merge берет все изменения из ветки и добавляет их в ветку master.

*❗️ Перед тем как сливать новый merge, стоит обновить локальную ветку master во избежании дальнейших проблем.*

**git merge --abort** откат слияния веток

Второй способ объединения изменений в ветках - это rebasing. При ребейзе Git по сути копирует набор коммитов и переносит их в другое место. Делаются чистые и красивые линейные последовательности коммитов. История коммитов будет чище, если вы применяете **git rebase название_ветки**.

Чтобы посмотреть текущее состояние ветки, например, какие файлы добавлены или не добавлены для создания commit, можно выполнить команду **git status**

Другие пользователи не увидят вашу ветку, пока она не будет отправлена на удаленный репозиторий. Поэтому, после того как вы слили все изменения в master , нужно отправить их в GitHub. Для этого обязательно нужно находиться в ветке master **git checkout master**

Отправляем наши изменения в GitHub
**git push origin master**

Таким же образом можно отправить любую другую ветку **git checkout <название_ветки>**

**git push origin <название_ветки>**

*! Каждый коммит лучше заливать сразу в удаленный репозиторий. Никто не застрахован от поломки собственного ПК. Поэтому, чтобы не потерять все наработки, не забывайте сливать ваши изменения на GitHub.*

Просмотреть изменения относительно двух веток можно командой **git diff <исходная_ветка> <целевая_ветка>**

Удалить ненужную ветку **git branch -d <название_ветки>**

Просмотр истории ветки **git log**

**git log graph** визуальное отображение ветвлений коммитов

### **Конфликты**
Иногда возникают конфликты. Например, когда в двух ветках были изменения в одной и той же строчке кода. Если такое произошло, то необходимо разрешить конфликт вручную. Для этого откройте файл там, где этого произошло.


Внести нужные изменения, добавить ваш файл через **git add <имя_файла>** как измененный и создать новый commit.

### **Перемещение ветки (branch forcing)**
Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции -f.  **git branch -f main HEAD~3** переместит (принудительно) ветку main на три родителя назад от HEAD.

## **Отмена изменений**
**git reset название_предыдущей_ветки** отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории". перенесёт ветку назад, как будто некоторых коммитов вовсе и не было. Отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удаленных ветках, которые используют другие пользователи.

**git revert название_измененной_ветки** чтобы отменить изменения и поделиться (git push) отмененными изменениями с остальными. 

## **Перемещение изменений**
rebase 

**git cherry-pick <Commit1> <Commit2> <...>** Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (HEAD) в заявленной последовательности. Удобно, когда точно известно, какие коммиты нужны (и известны их точные хеши). Поместит любой коммит сразу после HEAD (только если этот коммит не является предком HEAD)

**git rebase -i HEAD~4**- когда точно не известно какие коммиты нужны, можно использовать интерактивный rebase и отобрать нужный набор коммитов. Также показываются хеши коммитов и комментарии к ним.
После открытия окна интерактивного rebase есть три варианта для каждого коммита:
* Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе (у нас в окошке строку с коммитом можно перенести просто мышкой).
* Можно "выкинуть" коммит из ребейза. Для этого есть pick - переключение его означает, что нужно выкинуть коммит.
* Можно соединить коммиты. При помощи этой функции можно объединять изменения двух коммитов.

При каждом перемещении коммиты получают по апострофу. Также апостроф добавляется, когда мы делаем **git commit --amend**. 


## **Теги**
Ветки просто двигать туда-сюда и они часто ссылаются на разные коммиты как на изменения данных в ветке. Ветки просто изменить, они часто временны и постоянно меняют своё состояние. Для таких вещей, как релиз и большие слияния, нужно нечто более постоянное, чем ветка.


# show commands покажет все доступные инструкции. Там есть очень полезные, например undo и reset
А пока просто начни игру при помощи levels

## **Синтаксис языка Markdown**

    **Жирный текст** - ** или __ по обеим сторонам текста, который необходимо выделить

    *Курсивный текст* - * или _ по обеим сторонам текста, который необходимо выделить

    Вариативность * или _ нужна для того, чтобы при необходимости использовать единовременно в тексте оба инструмента, например: *джуны ленивые и хотят __ничего не делать__ и __зарабатывать много денег__*

    ~Зачеркнутый текст~ - ~по обеим сторонам текста, который необходимо выделить

    Показать уровень заголовка - подчеркивание знаками = или ****

    1, 2, 3... - нумерованные списки обозначаются обычными цифрами

    * Ненумерованные списки обозначаются * в начале строки
        Вложенные списки - выполняем отступы
    
    Вставка изображения
    Загрузить в рабочую папку изображение, проиндексировать и закоммитить его. Скопировать относительеый путь изображения. Ввести ![название_для_изображения](имя_файла)
   ![pict](pict.jpg)

    Переход по ссылке - <путь> 
    <https://use-web.ru/news.php?id=138&tid=3>

    Вставка цитаты 
    >Здесь цитата
    >в которой перед каждой новой строкой
    >ставится угловая скобка

# **Инструкция для работы с удаленным репозиторием**

## **Как опубликовать в GitHub**

Если ваш проект пустой, то создайте новый файл и назовите его index.html . После этого откроется окно редактирование этого файла. Напишите в нем ! и нажмите кнопку Tab . Автоматически должен сгенерироваться скелет пустой HTML страницы. Не забудьте нажать ctrl+s чтобы файл сохранился.

Давайте теперь перейдем во вкладу для работы с Git-ом.

После того, как выбрали "Опубликовать на GitHub публичный репозиторий", программа предложит вам выбрать файлы, которые будут входить в первый commit. Проставляем галочки у всех файлов, если не проставлены и жмем ОК . Вас перекинет на сайт GitHub, где нужно будет подтвердить вход в аккаунт. Вы создали и опубликовали репозиторий на GitHub.

Если вы хотите создать локальный репозиторий и опубликовать код в другой сервис, то необходимо нажать на кнопку Initialize Repository . После этого, вручную выбрать сервис куда публиковать.


### Теперь сделаем изменения в коде и попробуем их снова опубликовать. Перейдите во вкладку с файлами, отредактируйте какой-нибудь файл, не забудьте нажать crtl+s (Windows) или cmd+s (MacOS), чтобы сохранить файл. Вернитесь обратно во вкладу управления Git. Если посмотреть на значок вкладки Git, то можно увидеть цифру 1 в синем кружке. Она означает, сколько файлов у нас изменено и незакоммичено. Давайте его закоммитим и опубликуем:

*1. Кнопка для просмотра изменений в файле. Необязательно нажимать, указал для справки*

*2. Добавляем наш файл для будущего commit*

*3. Пишем комментарий*

*4. Создаем commit*

*5. Отправляем наш commit в GitHub*

## **Как скачать с GitHub**

Если у вашего друга раньше не было проекта, то ему придется его "клонировать" себе: **git clone <адрес_репозитория>**

*! Адрес репозитория на GitHub можно получить, нажав на зеленую кнопку Code*

После выполнения команды в папке, где появится проект и ваш друг сможет с ним работать, все ветки и их история также подтянутся.

Перед тем, как создавать новый функционал и новую ветку, стоит обновить master на вашем устройстве. Для этого нужно находиться в этой ветке и выполнить следующую команду **git checkout master**

Подтягиваем изменения из репозитория GitHub **git pull origin master**

Таким же образом можно актуализировать любую другую ветку, заменив название ветки master на вашу.

*! Для обновления всех веток сразу, можно использовать такую, команду, но не рекомендую **git pull***

Теперь можно создавать новую ветку и кодить.


